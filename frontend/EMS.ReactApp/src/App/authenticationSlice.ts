import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import  store2  from 'store2';

import axios, {AxiosResponse} from 'axios';
import  URLParse from 'url-parse';

import { RootState, store } from '../App/store';

import { login, logout } from './authenticationAPI';

enum LoginStateEnum {
  'logged_out', 'log_in' , 'logged_in' , 'log_out'
}

export interface LoginState {
    state: LoginStateEnum ;
    token: string | undefined;
    user: User | undefined,
  }
  
function  CreateState() : LoginState {
  var s : LoginState=  { 
    state: LoginStateEnum.logged_out, 
    token: undefined, 
    user: undefined 
  } ;

  var token = store2.session.get('token');
  if (token !== undefined && token !== null){
    // s.token = token;
    s.state = LoginStateEnum.logged_in;
    // store.dispatch(pingAsync()).then((x) =>{
    //   console.log("yuup");
    // });
  }
  return s;
}

function UpdateState(state: LoginState, s : LoginStateEnum, token?:string | undefined, user?:User | undefined) {  
  if (token !== null && token !== undefined)
    store2.session.set('token', token);
  else
    store2.session.remove('token');
  state.user = user;
  state.state = s;  
}

function UpdateState2(state: LoginState, s : LoginStateEnum, user?:User | undefined) {  
  state.user = user;
  state.state = s;  
}

const initialState = CreateState();

interface LoginResponse {
  token: string,
  user: User
}

interface User {
  id: string,
  username: string,
  name: string
}

interface ErrorResponse {
  status: string,
  statusText: string,
  message: string
}

// interceptor that will add the bearer token in the header when we are loged in
axios.interceptors.request.use(function (config) {
  var parsedUrl = URLParse(config.url as string, true);
  if (parsedUrl.pathname.startsWith('/api')){
    const token = store2.session.get('token');
    //const token = store.getState()?.authentication?.token;  
    if (token !== undefined && token !== null)  
      config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const loginAsync = createAsyncThunk<
      LoginResponse, 
      {username: string, secret: string},
      {rejectValue: ErrorResponse}
    >(
    'authentication/login',
    async ({username, secret}: {username: string, secret: string}, /* thunkApi */ { rejectWithValue }) => {
      try{
        var data = {username: username, password: secret};
        var cfg = undefined;
        var response = await axios.post<LoginResponse>('http://127.0.0.1:5000/api/users/authenticate', data, cfg);
        return response.data;
      }catch(err){        
        return rejectWithValue(
          {
            status: err.response.status, 
            statusText: err.response.statusText, 
            message: 'oeps'
          });
      }
    }
  );

export const logoutAsync = createAsyncThunk(
    'authentication/logout',
    async () => {
      const response = await logout();
      return response.data;
    }
  );

export const pingAsync = createAsyncThunk<
      LoginResponse, 
      undefined,
      {rejectValue: ErrorResponse}
    >(
    'authentication/ping',
    async (undefined, /* thunkApi */ { rejectWithValue }) => {
      try{
        var data = undefined;
        var cfg = undefined;
        var response = await axios.get<LoginResponse>('http://127.0.0.1:5000/api/users/ping', cfg);
        return response.data;
      }catch(err){        
        return rejectWithValue(
          {
            status: err.response.status, 
            statusText: err.response.statusText, 
            message: 'oeps'
          });
      }
    }
  );

export const authenticationSlice = createSlice({
    name: 'authentication',
    initialState,
    reducers: {
      increment: (state) => {
        console.log("increment...");
      },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
      builder
        .addCase(loginAsync.pending, (state) => {
          UpdateState(state, LoginStateEnum.log_in, undefined, undefined);
          console.info(`loginAsync.pending - ${state.state} `);                    
        })
        .addCase(loginAsync.fulfilled, (state, action) => {          
          UpdateState(
            state, 
            LoginStateEnum.logged_in, 
            action.payload.token, {
              id:action.payload.user.id, 
              username: action.payload.user.username, 
              name: action.payload.user.name 
            }); 
          console.info(`loginAsync.fulfilled - ${state.state} - ${action.payload.user.id} - ${action.payload.user.name}`);  
        })
        .addCase(loginAsync.rejected, (state, action ) => {
          UpdateState(state, LoginStateEnum.logged_out);     
          console.info(`login rejected - ${state.state} - ${action.payload?.status} - ${action.payload?.statusText}`);  
        })        
        .addCase(logoutAsync.pending, (state) => {
          UpdateState(state, LoginStateEnum.logged_out);
        })
        .addCase(logoutAsync.fulfilled, (state, action) => {
          UpdateState(state, LoginStateEnum.logged_out);
          console.info(`logged_out - ${state.state} - ${JSON.stringify(action.payload)}`);  
        })
        .addCase(pingAsync.fulfilled, (state, action) => {
          UpdateState2(
            state, 
            LoginStateEnum.logged_in, 
            {
              id:action.payload.user.id, 
              username: action.payload.user.username, 
              name: action.payload.user.name 
            }); 
        })
        .addCase(pingAsync.rejected, (state, action ) => {
          UpdateState(state, LoginStateEnum.logged_out);     
          console.info(`pong rejected - ${state.state} - ${action.payload?.status} - ${action.payload?.statusText}`);  
        })  
        ;
    },
  });

export const isLoggedIn = (state: RootState) => state.authentication.state == LoginStateEnum.logged_in;

export default authenticationSlice.reducer;      
